---
title:	"[Docker] Docker Overview"
date:	2023-12-07 12:00:00
categories:
  - Docker
tags:
  - Docker
comment: true
#published: true 
---
# Docker overview
- 개발, 적재, 애플리케이션 구동을 위한 오픈 플랫폼이다.
- 애플리케이션을 인프라 환경에서 분리하여 소프트웨어 공급을 빠르게 할 수 있다.
- 같은 인프라 환경을 제공함으로 써 애플리케이션을 항상 같은 환경에서 관리할 수 있다.
- 적재, 테스팅, 개발코드를 도커의 방식으로 활용하면 생산품의 코드 작성과 실행의 딜레이를 줄일 수 있다.

# The Docker platform
- 컨테이너라는 느슨한 결합력을 가진 환경에서 애플리케이션이 돌아갈 수 있게 해준다.
- 분리 및 보안으로 인해 주어진 호스트 환경에서 다수의 컨테이너를 동시에 실행시킬 수 있다.
- 컨테이너는 경량화 되고, 애플리케이션 구동에 위한 모든 구성을 갖추고있다.
  이로인해 호스트에 설치된 것에 구속 받지 않을 수 있다.
- 모든 사람이 동일한 환경에서 작업할 수 있도록 동일한 컨테이너를 확보해야한다.

-  컨테이너들의 생명주기를 관리할 수 있도록 툴과 플랫폼을 제공한다
  - 컨테이너를 사용하여 애플리케이션과 구성요소를 개발한다.
  - 컨테이너는 애플리케이션의 배포와 테스팅을 위한 유닛이 된다.
  - 준비가 되면, 애플케이션을 컨테이너혹은 편성된 서비스로 운영 환경에 배포한다.
    이는 어떤 환경에서도 동일한 환경을 제공할 것이다.

# What can I use Docekr for?
### 애플리케이션의 빠르고 일관된 제공
- 컨테이너를 사용하여 표준화된 환경에서 작업할 수 있도록 라이프 사이클을 간소화 시킨다.
- 컨테이너는 CI/CD(continuous Integration / Continuous Delivery) 워크플로우에 적합하다.

- 예시
  - 개발자는 로컬 환경에서 코드를 작성하고 이를 도커 컨테이너를 사용하여 동료들과 작업을 공유한다.
  - 도커를 통해 테스트 환경으로 애플리케이션을 반영 하고 자동/수동 테스트를 실행한다.
  - 개발자가 버그를 발견했을 때 개발 환경에서 버그를 수정하고 다시 개발 환경으로 반영한다.
  - 테스트가 끝나고 운영 환경으로 배포하는것은 테스트를 마친 이미지를 단순히 반영하면된다.

### 신속한 반영과 확장
- 도커 컨테이너 기반의 플랫폼들은 휴대성이 뛰어난 워크로드를 사용할 수 있게된다.
- 컨테이너들은 개발자의 로컬 환경, 물리 혹은 가상 머신, 클라우드 제공자, 혼합 환경 등에서 구동이 가능하다.

- 휴대성과 경량화는 동적으로 워크로드를 관리하는 것을 비지니스 요구 사항에 따라 거의 실시간으로 쉽게 확장, 해제가 가능하다.

### 같은 하드웨어에서 더 많은 워크로드를 실행.
- 도커는 가볍고 빠르다.
- 하이퍼바이저 기반의 가상 머신 대체하여 실행가능하고 비용 효율성을 제공한다.
- 비지니스 목적을 달성하기 위해 더 많은 서버를 가용할 수 있다.
- 고밀도 환경과 더 적은 리소스 활용으로 많은 작업을 수행해야하는 중소 규모에 적합하다.

# Docker architecture
- 클라이언트-서버 구조.
- 클라이언트는 도커 데몬(daemon)과 상호 작용을 하며 도커 컨테이너의 빌드, 실행, 배포 작업을 수행한다.
- 클라이언트와 데몬은 같은 시스템에서 구동하거나, 도커 클라이언트를 원격으로 도커 데몬과 연결하여 구동시킬 수 잇다.
- 클라이언트와 데몬은 UNIX 소켓 혹은 네트워크 인터페이스 너머로 REST API 소통을한다.
- 또 다른 도커 클라이언트로는 도커 컴포즈(Compose)가 있는데 이는, 컨테이너 세트로 이루어진 애플리케이션을 이용할 수 있게 해준다.
![Docker Architecture]({{ site.baseurl }}/assets/images/posts/2023/Docker/docker_architecture.png)

### The Docker daemon
- dockerd 라고도 불리오는 도커 데몬은 도커 API의 요청을 받거나, 이미지, 컨테이너, 네트워크, 볼륨과 같은 도커 오브젝트를 관리한다.
- 데몬은 도커 서비스를 관리하기위해 다른 데몬들과도 소통한다.
### The Docker client
- docker라고도 불리우는 도커 클라이언트는 도커와 사용자가 상호작용할 수 있는 주된 방법이다.
- `docker run` 과 같은 커맨드를 사용자가 입력하면 이는 Docker API를 통하여 dockerd(도커 데몬)로 명령이 전달, 실행된다.
- 도커 클라이언는 한 개 이상의 데몬과 소통이 가능하다.

### Docker Desktop
- Mac, Windows, Linux과 같은 환경에서 컨테이너화된 애플리케이션과 마이크로서비스를 빌드하고 공유할 수 있게해주는 설치가 쉬운 애플이케이션이다.
- Docker Desktop는 Docker daemon (dockerd), Docker client (docker), Docker Compose, Docker Content Trust, Kubernetes, Credential Helper 를 포함하고 있다.
- 자세한 사항은 [Docker Desktop](https://docs.docker.com/desktop/) 를 참고하자.

### Docker registries
- 도커 이미지들을 저장한다.
- Docker Hub는 누구나 사용할 수 있는 공용 레지스트리이며, 기본적으로 Docker Hub에 있는 이미지들을 기반으로 한다.
- 개인 레지스트리도 사용 가능하다.

- `docker pull`, `docker run` 커맨드 실행 시에 `docker pull` 로 사용자가 설정한 레지스트리에서 이미지를 가져온다.
- `docker push` 시에 사용자가 설정한 레지스트리에 이미지를 push 한다.

### Docker objects
- 도커를 사용할 때 이미지, 컨테이너, 네트워크, 볼륨, 플러그인, 혹은 다른 오브젝트들을 생성하고 사용하게된다.
#### Images
- 도커 컨테이너 생성을 위한 읽기전용 템플릿으로 인프라 환경을 포함한다.
- 흔히 이미지는 추가적인 커스텀과 함께 다른 이미지를 기반으로한다.
  예시로 ubuntu 이미지를 기반으로한다면 이미지를 빌드할 수 있겠지만, Apache 웹 서버와 본인 애플리케이션이 구동되게 이미지를 빌드할 수 있다.

- 이미지를 직접 만들거나 다른 사용자가 레지스트리에 등록한 이미지를 사용할 수 잇다.
- 사용자만의 이미지를 빌드하기 위해서는 간단한 구문과 함께 Dockerfile을 생성해야한다.
- Dockerfile은 이미지 안에서 각 구조들은 레이어화한다.
- Dockerfile을 변경하거나 이미지를 다시 빌드한다면 변경한 부분만 다시 빌드 될것이다.
  이로인해 이미지는 다른 가상화 방법보다 빠르고 경량화된다.

#### Containers
- 인스턴스화된 이미지를 구동할 수 있다.(이미지는 read-only)
- Docker API, CLI를 이용하여 컨테이너를 생성, 시작, 정지, 이동, 삭제의 동작을 수행한다.
- 컨테이너를 하나 혹은 하나이상의 네트워크에 연결하거나, 저장소를 붙이거나, 현재 상태를 기반으로 새로운 이미지를 생성할 수도 있다.

- 기본적으로 컨테이너는 다른 컨테이너와 호스트에 강한 종속성을 가지지 않는다.(격리 되어있다.)
- 다른 컨테이너 혹은 호스트 머신에서 컨테이너의 네트워크, 저장소, 내제된 서브시스템에서 어떻게 격리할 수 있는지 설정할 수 있다.

- 컨테이너 이미지와 생성과 컨테이너 생성과 시작 단계에서 설정한 옵션에 의해 정의될 수 있다.
- 컨테이너가 삭제 되었을 때, 영구적인 저장소에 저장되지 않은 변경 상태들 사라진다.

#### Example docker run command
```docker run -i -t ubuntu /bin/bash```
의 명령어는 ubuntu 컨테이너를 실행시키고, 로컬 커멘드라인 세션과 상호 관계를 맺게하며, /bin/bash를 실행 시킨다.

기본 레지스트리 설정을 이용한다면 커맨드 실행 시 아래의 과정을 거치게 된다.
1. ubuntu 이미지가 로컬에 없다면 도커는 `docker pull ubuntu` 를 실행한 것 처럼 설정된 레지스트리에서 이미지를 pull 해온다.
2. `docker container create` 를 실행한 것처럼 도커는 새로운 컨데이터를 생성한다.
3. 마지막 레이어에 읽고 쓸 수 있는 파일 시스템을 컨테이너에 위치시킨다.
   이로 인해 로컬 파일 시스템에서 컨테이너를 생성하거나 파일과 디텍터리를 수정하는 동작을 수행할 수 있게된다.
4. 네트워킹 옵션을 정의하지 않아도 도커는 기본 네트워크에 컨테이너를 연결하기 위한 네트워크 인터페이스를 생성한다.
   이 과정에는 컨테이너에 IP 주소를 배정하는 작업도 포함된다.
   기본적으로 호스트 머신의 네트워크 커넥션을 이용하여 컨테이너를 외부 네트워크에 연결 시킬 수도 있다.
5. 도커는 `/bin/bash`를 실행시킨다.
   이는 `-i -t` 의 옵션을 줌으로써 컨테이너가 현재 사용중인 터미널과 상호 작용하며 동작한다.
   터미널을 통해 오커 로그가 출력되는 동안 키보드를 통해 input을 제공할 수 있다.
6. 실행되고 있는 터미널에서 `exit`를 한다면 컨테이너는 정지하겠지만 사라지지는 않는다.
   이후 다시 실행하거나 제거할 수 있다.


# The underlying technology
- 도커는  [Go programming languageopen_in_new](https://golang.org/) 로 개발되었고 Linux kernel의 기능을 활용했기에 이점을 가져올 수 있다.
- `namespaces`라고 불리우는 기술로 컨테이너 즉, 격리된 워크스페이스를 제공한다.
- 컨테이너를 실행하면 도커는 실행하는 컨테이너의 namespaces set을 만든다.
- 이 namespaces는 격리된 레이어를 제공하며, 컨테이너는 각자의 namespace에서만 실행된다.

ref.  
[https://docs.docker.com/get-started/overview/](https://docs.docker.com/get-started/overview/)